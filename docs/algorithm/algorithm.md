# Algorithm

## 시간 복잡도

```text
O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < O(2^N) < O(N!)
```

컴퓨터는 1초에 대략 간단한 연산을 1억 번 정도 한다고 가정한다. 

N과 M이 주어진다.

- 입력은 최대 N = 1000, M = 10000이다.
- 시간 복잡도는 O(NM)이다.
- 최대 1000만 번 연산을 하게 될 수도 있다.

이 경우는 문제가 없다.

다시 N과 M이 주어진다.

- 입력은 최대 N = 1000, M = 1000000이다.
- 시간 복잡도는 O(NM)이다.
- 최대 1억 번 연산을 하게 될 수도 있다.

이 경우는 문제가 있다. 1억번의 연산을 하게 두면 안 된다.

O(NlogM) 알고리즘을 적용한다.

이 경우 똑같은 입력값(N = 1000, M = 1000000)일 때, 대략 130만 ~ 140만 번의 연산으로 해결할 수 있다. logM은 대략 13 ~ 14 정도이기 때문이다.

<br />

## 탐색
### DFS(Depth-First Search)
노드 개수 V, 엣지 개수 E 일 때, O(V + E)
- 완전 탐색 기법
- 한 쪽 분기를 선택, 최대 깊이까지 탐색 후 다른쪽 분기로 이동 후 재탐색

### BFS(Breath-First Search)
노드 개수 V, 엣지 개수 E 일 때, O(V + E)
- 완전 탐색 기법
- 시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 우선 탐색

### Binary Search
O(logN)
- 데이터가 정렬되어 있는 상태에서 원하는 값을 찾는 알고리즘
- 대상 데이터의 중앙값과 찾고자 하는 값을 비교해 데이터의 탐색 범위를 절반씩 줄이면서 탐색

## 그리디(Greedy)

## 그래프(Graph)
### 그래프의 표현
### 유니온 파인드(Union Find)
### 위상 정렬

## 최단경로

### 다익스트라(Dijkstra)
간선 수 E, 노드 수 V일 때, O(ElogV)
- 출발점에서 목표점까지 최단 경로를 구함
- 한 노드에서 다른 모든 노드로의 최단 경로를 구할 수 있음
- 간선에 음수값(음의 가중치)이 없어야 정상작동
- 그리디 + DP 형태

### 벨만-포드
간선 수 E, 노드 수 V일 때, O(VE)
- 음수 간선이 포함되어 있는 경우에도 최단 경로를 구함
  - 음수 사이클이 있는 경우 정상동작 하지 않음
- 매번 모든 간선을 확인하기 때문에 Dijkstra에 비해 느림


### 플로이드-워셜
### 최소 신장 트리

## 트리(Tree)
### 트라이
### 이진 트리
### 세그먼트 트리
### 최소 공통 조상

## 조합

## DP(Dynamic Programming)

## 기하