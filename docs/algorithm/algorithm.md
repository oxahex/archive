# Algorithm

## 시간 복잡도

```text
O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < O(2^N) < O(N!)
```

컴퓨터는 1초에 대략 간단한 연산을 1억 번 정도 한다고 가정한다. 

N과 M이 주어진다.

- 입력은 최대 N = 1000, M = 10000이다.
- 시간 복잡도는 O(NM)이다.
- 최대 1000만 번 연산을 하게 될 수도 있다.

이 경우는 문제가 없다.

다시 N과 M이 주어진다.

- 입력은 최대 N = 1000, M = 1000000이다.
- 시간 복잡도는 O(NM)이다.
- 최대 1억 번 연산을 하게 될 수도 있다.

이 경우는 문제가 있다. 1억번의 연산을 하게 두면 안 된다.

O(NlogM) 알고리즘을 적용한다.

이 경우 똑같은 입력값(N = 1000, M = 1000000)일 때, 대략 130만 ~ 140만 번의 연산으로 해결할 수 있다. logM은 대략 13 ~ 14 정도이기 때문이다.

<br />

## 탐색
### DFS(Depth-First Search)
노드 개수 V, 엣지 개수 E 일 때, O(V + E)
- 완전 탐색 기법
- 한 쪽 분기를 선택, 최대 깊이까지 탐색 후 다른쪽 분기로 이동 후 재탐색

### BFS(Breath-First Search)
노드 개수 V, 엣지 개수 E 일 때, O(V + E)
- 완전 탐색 기법
- 시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 우선 탐색

### Binary Search
O(logN)
- 데이터가 정렬되어 있는 상태에서 원하는 값을 찾는 알고리즘
- 대상 데이터의 중앙값과 찾고자 하는 값을 비교해 데이터의 탐색 범위를 절반씩 줄이면서 탐색

## 그리디(Greedy)

## 그래프(Graph)
### 그래프의 표현
### 유니온 파인드(Union Find)
### 위상 정렬
### 다익스트라
### 벨만-포드
### 플로이드-워셜
### 최소 신장 트리

## 트리(Tree)
### 트라이
### 이진 트리
### 세그먼트 트리
### 최소 공통 조상

## 조합

## DP(Dynamic Programming)

## 기하