# Algorithm

## 시간 복잡도

```text
O(1) < O(logN) < O(N) < O(NlogN) < O(N^2) < O(N^3) < O(2^N) < O(N!)
```

컴퓨터는 1초에 대략 간단한 연산을 1억 번 정도 한다고 가정한다. 

N과 M이 주어진다.

- 입력은 최대 N = 1000, M = 10000이다.
- 시간 복잡도는 O(NM)이다.
- 최대 1000만 번 연산을 하게 될 수도 있다.

이 경우는 문제가 없다.

다시 N과 M이 주어진다.

- 입력은 최대 N = 1000, M = 1000000이다.
- 시간 복잡도는 O(NM)이다.
- 최대 1억 번 연산을 하게 될 수도 있다.

이 경우는 문제가 있다. 1억번의 연산을 하게 두면 안 된다.

O(NlogM) 알고리즘을 적용한다.

이 경우 똑같은 입력값(N = 1000, M = 1000000)일 때, 대략 130만 ~ 140만 번의 연산으로 해결할 수 있다. logM은 대략 13 ~ 14 정도이기 때문이다.

<br />

## 탐색
### DFS(Depth-First Search)
노드 개수 V, 엣지 개수 E 일 때, O(V + E)
- 완전 탐색 기법
- 한 쪽 분기를 선택, 최대 깊이까지 탐색 후 다른쪽 분기로 이동 후 재탐색

### BFS(Breath-First Search)
노드 개수 V, 엣지 개수 E 일 때, O(V + E)
- 완전 탐색 기법
- 시작 노드에서 출발해 시작 노드를 기준으로 가까운 노드를 우선 탐색

### Binary Search
O(logN)
- 데이터가 정렬되어 있는 상태에서 원하는 값을 찾는 알고리즘
- 대상 데이터의 중앙값과 찾고자 하는 값을 비교해 데이터의 탐색 범위를 절반씩 줄이면서 탐색

## 그리디(Greedy)

## 그래프(Graph)
### 그래프의 표현
### 유니온 파인드(Union Find)
### 위상 정렬

## 최단경로

### 다익스트라(Dijkstra)
간선 수 E, 노드 수 V일 때, O(ElogV)
- 출발점에서 목표점까지 최단 경로를 구함
- 한 노드에서 다른 모든 노드로의 최단 경로를 구할 수 있음
- 간선에 음수값(음의 가중치)이 없어야 정상작동
- 그리디 + DP 형태

### 벨만-포드
간선 수 E, 노드 수 V일 때, O(VE)
- 음수 간선이 포함되어 있는 경우에도 최단 경로를 구함
  - 음수 사이클이 있는 경우 정상동작 하지 않음
- 매번 모든 간선을 확인하기 때문에 Dijkstra에 비해 느림


### 플로이드-워셜
### 최소 신장 트리

## 트리(Tree)
### 트라이
### 이진 트리
### 세그먼트 트리
### 최소 공통 조상

## 조합

## DP(Dynamic Programming)

## 기하


입출력
- [x] 2557
- [x] 1000
- [x] 2558
- [x] 10950
- [x] 10951
- [x] 10952
- [x] 10953
- [x] 11021
- [x] 11022
- [x] 11718
- [ ] 11719
- [x] 11720
- [ ] 11721
- [x] 2741
- [ ] 2742
- [x] 2739
- [ ] 1924
- [x] 8393
- [x] 10818
- [x] 2438
- [x] 2439
- [ ] 2440
- [ ] 2441
- [ ] 2442
- [ ] 2445
- [ ] 2522
- [ ] 2446
- [ ] 10991
- [ ] 10992

DP
- [x] 1463
- [x] 11726
- [x] 11727
- [x] 9095
- [x] 10844
- [x] 11057
- [x] 2193
- [x] 9465
- [ ] 2156
- [ ] 11053
- [ ] 11055
- [ ] 11722
- [ ] 11054
- [ ] 1912
- [ ] 2579
- [ ] 1699
- [ ] 2133
- [ ] 9461
- [ ] 2225
- [ ] 2011
- [ ] 11052

2751, 11650, 11651, 10814, 10825, 10989, 11652, 11004, 10828, 9012, 10799, 10845, 10866, 10808, 10809, 10820, 2743, 11655, 10824, 11656, 1406, 1158, 1168, 10430, 2609, 1934, 1850, 9613, 11005, 2745, 1373, 1212, 2089, 11576, 1978, 1929, 6588, 11653, 10872, 1676, 2004

그래프 - 1260, 11724, 1707, 10451, 2331, 9466, 2667, 4963, 7576, 2178, 2146, 1991, 11725, 1167, 1967

이분탐색/삼분탐색 - 1654, 2805, 2110, 10815, 10816, 11662

분할정복 - 11728, 1780, 11729, 1992, 2447, 2448, 1517, 2261



그리디 - 11047, 2875, 10610, 1783, 1931, 11399, 2873, 1744

완전탐색 - 1476, 1107, 1451, 9095, 10819, 10971, 1697, 1963, 9019, 1525, 2251, 2186, 3108, 5014, 1759, 2580, 1987, 6603, 1182, 2003, 1806, 1644, 1261, 1208, 7453, 2632, 2143



```java
//11718
public class Main {
    public static void main(String[] args) throws Exception {
        byte[] b = new byte[10000];
		System.in.read(b);
		System.out.println(new String(b).trim());
    }
}
```