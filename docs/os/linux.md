# Linux

## File System
### `/`
- 파일 체제의 최상위 디렉토리
- 모든 디렉토리의 시작점으로 일반적인 데이터를 저장하지 않음

### `/bin`
- binaryse라는 뜻
- 리눅스의 기본 명령어(binary)들이 들어있는 디렉토리
- 시스템을 운영하기 위한 기본적인 명령어들이 있음

### `/boot`
- 부팅에 핵심적인 커널 이미지와 부팅 정보 파일을 담고 있음
- /etc/lilo.conf`에서 지정한 커널 부팅 이미지 파일이 들어있음

### `/dev`
- 장치 파일들이 저장되어 있음
- 연결되어 있는 장치의 정보를 확인할 수 있음

### `/etc`
- 시스템 환경 설정 파일이 있음
- 네트워크 관련 설정 파일, 사용자 정보 및 암호 정보, 파일 시스템 정보, 보안 파일 등

### `/home`
- 리눅스 사용자의 홈 디렉토리가 만들어지는 디렉토리
- 사용자의 홈 디렉토리는 사용자의 계정명과 일치하게 만들어짐

### `/initrd`
- 사용자 정의 initrd 부팅 프로세스를 만들었을 때 사용

### `/lost+found`
- 루트 디렉토리에 있었던 파일들을 위해 lost+found 시스템을 제공

### `/lib`
- 시스템 라이브러리

### `/media`
- CD_ROM이나 USB 같은 외부 장치를 연결하는 디렉토리

### `/mnt`
- 파일 시스템을 임시로 연결하는 디렉토리
- 수동으로 마운트된 하드 드라이브 파일 시스템들을 저장

### `/opt`
- 추가적인(optional) 프로그램들의 설치 경로

### `/proc`
- 현재 실행중인 프로세스를 포함한 시스템 정보를 저장하는 동적인 디렉토리

### `/root`
- 시스템 관리자의 홈 디렉토리
- 일반 사용자는 접근할 수 없음

### `/sbin`
- `/bin` 디렉토리와 유사하지만 root 유저만 실행할 수 있는 프로그램을이 있음

### `/sys`
- 리눅스 커널 관련 정보가 있는 디렉토리

### `/tmp`
- 시스템 사용 중 발생한 임시 데이터가 저장되는 디렉토리
- 부팅 시 초기화

### `/usr`
- 기본 실행 파일과 라이브러리 파일, 헤더 파일 등의 파일이 저장되는 디렉토리
- 대부분의 응용 프로그램과 파일이 여기에 저장

### `/var`
- 시스템 운영 중에 발생한 데이터와 로그가 저장되는 디렉토리
- 로그와 데이터베이스 같은 가변 파일

## File
### 생성
- 새로운 파일(원본파일)을 생성하면 그 파일은 inode를 가리키고 inode가 data를 가리킨다.
- 원본파일을 지우더라도 데이터를 삭제하는 것은 아니고 원본파일이 inode를 가리키는 링크를 제거하는 것임. 따라서 데이터파일은 하드디스크 어딘가에 저장되어 있다.
- cp를 하면 새로운 original Data와 새로운 inode2가 생성되고 원본파일을 복사한 data가 생성된다.
- hard link로 파일을 복사하면 같은 inode를 가리키는 파일이 생성되어 완벽히 복제된다. 따라서 원본파일이 변경되면 복사한 파일이 변경되고 원본파일이 제거되더라도 복사한 파일은 제거되지 않는다.
- 심볼릭 링크를 걸게 되면 새로운 inode를 생성하여 그 inode를 가리키고 새로운 inode는 원본 파일을 가리키는 링크를 생성한다. 따라서 원본파일이 변경되게 되면 심볼릭 링크도 변경되고 원본 파일이 삭제되면 심볼릭 링크에 이상이 생긴다.

## Soft Link & Hard Link
심볼릭 링크(소프트 링크)는 일종의 바로가기 링크로 설명할 수 있음. 심볼릭 링크를 지운다고 해서 이 파일이 가리키고 있는 실제 파일이 삭제되는 것은 아니다. 원본 파일 삭제 시 소프트 링크는 사용이 불가능.

하드링크를 이용하는 경우 두 파일은 같은 inode를 가진다. 따라서 둘 중 하나의 파일을 수정하면, 다른 한 파일도 함께 수정된다. 또 둘 중 하나를 삭제해도 나머지 한 파일에 접근하면 동일한 데이터를 얻을 수 있다. 물론 둘 다 지우면 그냥 사라지겠죠...



## System Call Interrupt
```shell
# 내부 코드
mov eax, 0x01 			# 시스템 콜 번호
mov ebx, 0x00			# 인자 값
int 0x80				# 소프트웨어 인터럽트 명령(CPU op code + 인터럽트 번호)
```
1. eax 레지스터에 호출할 시스템 콜 번호를 넣음(이미 등록되어 있음). 어떤 시스템 콜을 호출할 지 여기서 초기화 진행.
2. ebx 레지스터에 시스템 콜에 해당하는 인자 값을 넣는다(e.g. `open()`, `O_READONLY`)
3. `int`라는 소프트웨어 인터럽트 명령을 호출하면서 `0x80` 값을 넣음(`0x80`는 인터럽트 정보를 관리하는 IDT(Interrupt Descriptor Table)에서 system_call()이라는 함수가 있는 주소Code를 의미).
4. CPU는 사용자 모드를 커널 모드로 바꿈. 
5. IDT에서 `0x80`에 해당하는 주소Code(함수)를 찾아 실행. 이 때 eax와 ebx 값도 함께 전달. 
6. 이 때 eax 레지스터를 확인해서 시스템 콜 번호를 확인하고, 해당하는 시스템 콜을 호출. 
7. ebx에서 시스템 콜 함수의 인자를 넘겨주고 함수 실행.
8. 함수의 결과를 프로세스에 보내고 CPU는 커널 모드에서 다시 사용자 모드로 돌아가 프로세스를 이어서 실행.