package boj.gold;

import java.util.Scanner;

/**
 * @date    2023-08-18
 * @title   K번째 수(1300) G1
 * @tags    Binary Search
 * @input
 * 첫째 줄에 배열의 크기 N 이 주어진다.
 * N은 10^5 보다 작거나 같은 자연수이다.
 * 둘째 줄에 k가 주어진다. k는 min(10^9, N^2) 보다 작거나 같은 자연수이다.
 * @output
 * B[k]를 출력한다.
 */
public class BOJ_1300 {

    /**
     * <pre>
     *     처음 시도는 2중 반복문을 사용해서 O(N^2) 복잡도로 했는데, 입력 값 최대 크기를 생각하면 시간 초과다.
     *     이걸 보고 이진탐색을 이용해서 풀겠다고 생각하는 건 좀 어렵지 않나...
     *
     *      - N * N 배열의 각 행은 i 의 배수로 이루어져 있다.
     *      - 답은 N * N 보다 클 수 없다.
     *      - B[k] 를 표현할 수 있는 다른 방법을 찾아야 한다. 규칙이 있을 것임.
     *
     *     N = 3, k = 7 인 경우, 2차원 배열은 다음과 같다.
     *     -------------
     *      1    2    3
     *      2    4    6
     *      3    6    9
     *     -------------
     *     이를 1차원 배열로 표현하면 B = {1, 2, 2, 3, 3, 4, 6, 6, 9} 이다.
     *     B[7] 은 B 배열에서 7 번째에 위치한 수를 의미하므로, B[7] 보다 작거나 같은 수는 k - 1 개 라고 할 수 있다.
     *     이 때, 7 번째에 위치한 수는 7 보다 클 수 없다. 같을 수는 있다.
     *     따라서 정답의 범위는 1 ~ k 사이의 숫자임.
     *
     *     1 ~ k 를 탐색해 2차원 배열에서 탐색하는 수와 같거나 작은 수가 k - 1 개인 것을 찾는다.
     *     k 의 범위는 min(10^9, N^2) 이므로 순차적으로 탐색하면 시간 초과. 이진 탐색을 이용한다.
     *
     *     2차원 배열의 각 행은 i 로 시작하고, i * 1, i * 2, i * 3 으로 커진다.
     *     중앙 값 / i = 작거나 같은 수의 개수, 만약 (중앙 값 / i) < N 을 만족하면 N 이 작거나 같은 수의 개수가 된다.
     *
     *     작거나 같은 수의 개수를 C 라고 하면,
     *     C 는 k 보다 작으면 안 된다. C 는 k 를 포함하므로 k 보다 작으면 구하려는 B[k] 보다 더 작은 값이다.
     *     이 경우 start = mid + 1 해서 탐색 범위를 큰 쪽으로 옮긴다.
     *     C 가 k 와 같거나 큰 경우, end = mid - 1 로 탐색 범위를 작은 쪽으로 옮긴다.
     *     이 때, mid 는 정답 가능성이 있다.
     *     i * j 의 결과와 j * i 의 결과는 같고, 이는 배열 B 에서 연속적으로 등장하게 된다.
     *
     *     k = 7 일 때,
     *     탐색 범위는 1 ~ 7, mid = 4 이다.
     *     4 보다 작거나 같은 수는 1, 2, 2, 3, 3 총 5 개. 좀 더 큰 값이 답이 된다.
     *     start = mid + 1 -> mid = 6 으로 탐색을 이어 가면,
     *     6 보다 작거나 같은 수는 1, 2, 2, 3, 3, 4, 6, 6 총 8 개.
     *     end = mid - 1 -> mid = 5 로 탐색을 이어 가면,
     *     5 보다 작거나 같은 수는 1, 2, 2, 3, 3, 4 총 5 개. -> 6 이 답이 된다.
     *
     *     여기서 5 는 배열 상에서 실재하지 않는 수다. 즉, 어떤 수의 연속이라고 볼 수 있음.
     *     5 보다 작거나 같은 수는 4보다 작거나 같은 수의 개수와 같다.
     * </pre>
     * */
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        int k = sc.nextInt();

        long start = 1;
        long end = k;
        long answer = 0;
        while (start <= end) {
            long mid = (start + end) / 2;

            long cnt = 0;
            for (int i = 1; i <= N; i++) {
                cnt += Math.min(mid / i, N);
            }

            if (cnt < k) {
                start = mid + 1;
            } else {
                answer = mid;
                end = mid - 1;
            }
        }

        System.out.println(answer);
    }
}
