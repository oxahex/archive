package boj.silver;

import java.util.Scanner;

/**
 * @date    2023-09-27
 * @title   오르막 수(11057) S1
 * @tags    DP, Prefix Sum
 * @input
 * 첫째 줄에 N (1 ≤ N ≤ 1,000)이 주어진다.
 * @output
 * 첫째 줄에 길이가 N인 오르막 수의 개수를 10,007로 나눈 나머지를 출력한다.
 */
public class BOJ_11057 {

    /**
     * <pre>
     *     구하려는 것
     *      - 특정 자릿수에서 만들 수 있는 오르막 수의 개수
     *
     *     오르막 수는 어떻게 결정되나?
     *      - 어떤 숫자로 끝나는가?
     *      - 어떤 숫자로 끝났다고 가정했을 때, 그 앞에 올 수 있는 수의 가짓수를 알면 된다.
     *
     *      dp[자릿수][끝나는 수]를 의미하는 dp 배열을 생성
     *      dp[1][0 ~ 9] -> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 로 초기화
     *      dp[2][0] -> _0 형태의 숫자일 때 _에 올 수 있는 수로 끝나는 오르막 수의 개수가 된다.
     *
     *      _0 -> 00
     *      _1 -> 00, 01
     *      _2 -> 00, 01, 02
     *      _3 -> 00, 01, 02, 03
     *
     *      결국 dp[현재 자릿수 - 1][0 ~ 끝나는 수] 까지의 모든 수를 더한 값을 넣어야 함.
     *      이 부분을 매 계산마다 더해주게 되면 3중 for문을 사용하게 되는데,
     *      어차피 0 ~ 현재 끝나는 수 만큼의 값을 계속 더해주어야 하므로 연산 시 이전 값을 더해서 저장하도록 최적화 할 수 있다.
     *      이게 가능한 이유는 구하고자 하는 것이 특정 자릿수에서 만들 수 있는 오르막 수의 개수이지 특정 자릿수에서 N으로 끝나는 오르막 수를 구하는 것이 아님.
     *      (물론 이것도 prefix sum 으로 연산 결과를 저장하면 dp[자릿수][N] - dp[자릿수][N - 1]로 구할 수 있긴 함.)
     *
     *      구하고자 하는 값이 특정 자릿수의 오르막 수의 개수이므로 0 ~ 9로 끝나는 모든 케이스가 합산된 dp[N][9]가 답이 된다.
     * </pre>
     */
    final static int MOD = 10007;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();
        int[][] dp = new int[N + 1][10];

        for (int i = 0; i < 10; i++) {
            dp[1][i] = i + 1;
        }

        for (int i = 2; i <= N; i++) {
            dp[i][0] = dp[i - 1][0];
            for (int j = 1; j < 10; j++) {
                dp[i][j] = (dp[i - 1][j] + dp[i][j - 1]) % MOD;
            }
        }

        System.out.println(dp[N][9]);
    }
}