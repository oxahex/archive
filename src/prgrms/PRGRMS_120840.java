package prgrms;

/**
 * @date    2023-07-14
 * @title   구슬을 나누는 경우의 수(120840), L0
 * @tags    수학, 정수론
 * @input
 * 머쓱이가 갖고 있는 구슬의 개수 balls와 친구들에게 나누어 줄 구슬 개수 share이 매개변수로 주어진다.
 * @output
 * balls개의 구슬 중 share개의 구슬을 고르는 가능한 모든 경우의 수를 return 하는 solution 함수를 완성해주세요.
 */
public class PRGRMS_120840 {

    /**
     * <pre>
     *     제한사항
     *     - 1 <= balls <= 30
     *     - 1 <= share <= 30
     *     - 구슬을 고르는 순서는 고려하지 않음
     *     - share <= balls
     *
     *     이 문제가 재미있었던 이유는 서로다른 n개 중 m개를 고르는 경우의 수 공식을 문제에서 공개했다.
     *     재귀함수를 이용해 Factorial을 구현하면 풀 수 있는 문제라고 생각했으나
     *     TC (30, 15) 에서 int, long 타입으로 계산을 시도하는 경우 Overflow가 발생한다.
     *     따라서 다른 방법이 필요했음.
     *
     *     두 번째로 고민한 방법은 Factorial 계산 전에 미리 약분을 해주는 건데
     *     이 케이스 역시 Overflow가 발생했다.
     *
     *     마지막 방법은 분자와 분모를 따로 구해 나누기를 해주는 것이 아니라, 먼저 나누고 곱하는 방식.
     *     이 경우 발생할 수 있는 문제는 9 / 3 경우와 같이 무한 소수가 나오는 경우 손실이 발생한다는 점.
     *     케이스를 몇 개 더 그려보면서 시도했는데,
     *
     *     CASE 1: 14개 중 6개를 고른다면,
     *     분자: 14 x 13 x 12 x 11 x 10 x 09
     *     분모: 06 x 05 x 04 x 03 x 02 x 01
     *
     *     CASE 2: 30개 중 15개를 고른다면,
     *     분자: 30 x 29 x 28 x 27 x 26 x 25 x 24 x 23 x 22 x 21 x 20 x 19 x 18 x 17 x 16
     *     분모: 15 x 14 x 13 x 12 x 11 x 10 x 09 x 08 x 07 x 06 x 05 x 04 x 03 x 02 x 01
     *
     *     이런 식으로 분자와 분모의 개수가 같아진다.
     *          분자의 범위는 m + 1 <= numer <= n
     *          분모 범위는 1 <= denom <= m
     *     그러면 CASE 1의 경우 14/6 * 13/5 *, ..., * 9/1 이런 식으로 계산할 수 있다.
     *     문제는 여기서도 소수점 손실 문제가 발생할 수 있는데, 순서를 바꾸면 가능하다.
     *     CASE 1의 경우 14 / 1 * 13 / 2 * 12 / 3 ...과 같이 진행되는데,
     *     분자의 소인수가 분모의 소인수를 전부 포함하고 있을 것이라는 생각에서 시도했다.
     *
     *     그런데 아직 분자의 소인수가 분모의 소인수를 포함하지 않는 경우나(반례),
     *     분자의 소인수가 분모의 소인수를 모두 포함하고 있을 거라는 예측을 증명 못함.
     *     그보다 이렇게 추측했다는 것이 좀 더 내 생각과 가까운 것 같다.
     *     1 부터 m 순서로 나누기 때문에 이 수들은 나눠야 하는 수의 소인수일 확률이 높다.
     *
     *     Q. 1 부터 m 순서로 나누기 때문에 이 수들은 나눠야 하는 수의 소인수인 이유는?
     *     A. n개 중 m개를 고르는 경우는 반드시 자연수(n>=m일 때).
     *        그리고 해당 for문에 의해 계산되는 answer 값은 n개 중 i개를 고르는 경우에 해당.
     *        따라서 마찬가지로 항상 자연수가 된다. 그렇기 때문에 이 방법은 항상 잘 동작하게 된다.
     *
     *     공식의 물리적인 의미를 생각하시면 반드시 모든 소인수가 포함된다는 사실(소인수가 남으면 항상 소숫점이 발생하므로)
     *     이렇게 수학적으로 파고들지 않고 파악할 수 있는 정도는 괜찮으나, 이 이상 수학적으로(정수론 기반의) 파고들어야 한다면 굳이?
     *     실무에서는 이 방법이 떠오르지 않을 경우 BigInteger를 사용하되, 성능적인 이슈가 있을 때 최적화 방법으로 선택하시면 좋을 것 같음.
     * </pre>
     * */
    public int solution(int balls, int share) {
        long answer = 1;
        for (int i = 1; i < share + 1; i++) {
            answer *= (balls - i + 1);
            answer /= i;
        }

        return (int) answer;
    }
}
